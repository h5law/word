/* hotp.c
 * Copyright (c) 2025 - h5law <dev@h5law.com>
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgement in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

/* HTOP - Algorithm notation and keywords
 * -------------------------------------------------------------------
 * A string always means a binary string, meaning a sequence of zeros
 * and ones.
 * If s is a string, then |s| denotes its length.
 * If n is a number, then |n| denotes its absolute value.
 * If s is a string, then s[i] denotes its i-th bit.  We start numbering
 * the bits at 0, so s = s[0]s[1]...s[n-1] where n = |s| is the length
 * of s.
 * Let StToNum (String to Number) denote the function that as input a
 * string s returns the number whose binary representation is s. (For
 * example, StToNum(110) = 6.)
 * -------------------------------------------------------------------
 * Symbol  Represents
 * -------------------------------------------------------------------
 * C       8-byte counter value, the moving factor.  This counter
 *         MUST be synchronized between the HOTP generator (client)
 *         and the HOTP validator (server).
 * K       shared secret between client and server; each HOTP
 *         generator has a different and unique secret K.
 * T       throttling parameter: the server will refuse connections
 *         from a user after T unsuccessful authentication attempts.
 * s       resynchronization parameter: the server will attempt to
 *         verify a received authenticator across s consecutive
 *         counter values.
 * Digit   number of digits in an HOTP value; system parameter.
 * -------------------------------------------------------------------
 *                 HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
 * -------------------------------------------------------------------
 * Where:
 *   - Truncate represents the function that converts an HMAC-SHA-1
 *     value into an HOTP value as defined in Section 5.3.
 * The Key (K), the Counter (C), and Data values are hashed high-order
 * byte first.
 * The HOTP values generated by the HOTP generator are treated as big
 * endian.
 * -------------------------------------------------------------------
 *           Example of HOTP Computation for Digit = 6
 * -------------------------------------------------------------------
 * The following code example describes the extraction of a dynamic
 * binary code given that hmac_result is a byte array with the HMAC-
 * SHA-1 result:
 *      int offset   =  hmac_result[19] & 0xf ;
 *      int bin_code = (hmac_result[offset]  & 0x7f) << 24
 *         | (hmac_result[offset+1] & 0xff) << 16
 *         | (hmac_result[offset+2] & 0xff) <<  8
 *         | (hmac_result[offset+3] & 0xff) ;
 * SHA-1 HMAC Bytes (Example)
 * -------------------------------------------------------------
 * | Byte Number                                               |
 * -------------------------------------------------------------
 * |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
 * -------------------------------------------------------------
 * | Byte Value                                                |
 * -------------------------------------------------------------
 * |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
 * -------------------------------***********----------------++|
 * * The last byte (byte 19) has the hex value 0x5a.
 * * The value of the lower 4 bits is 0xa (the offset value).
 * * The offset value is byte 10 (0xa).
 * * The value of the 4 bytes starting at byte 10 is 0x50ef7f19,
 *   which is the dynamic binary code DBC1.
 * * The MSB of DBC1 is 0x50 so DBC2 = DBC1 = 0x50ef7f19 .
 * * HOTP = DBC2 modulo 10^6 = 872921.
 * We treat the dynamic binary code as a 31-bit, unsigned, big-endian
 * integer; the first byte is masked with a 0x7f.
 * We then take this number modulo 1,000,000 (10^6) to generate the 6-
 * digit HOTP value 872921 decimal.
 */

#include <stdint.h>
#include <string.h>

#include <openssl/hmac.h>
#include <openssl/evp.h>

#include "hotp.h"

static const uint64_t pow[10] = {1,          10,         100,      1000,
                                 10000,      1000000,    10000000, 100000000,
                                 1000000000, 10000000000};

uint8_t *reverse_str(const uint8_t *data, uint8_t *rev, size_t data_len)
{
    int left = 0, right = data_len - 1;
    while (left < right) {
        rev[right] = (data[left] & 0xF0) | (data[left] & 0x0F);
        rev[left]  = (data[right] & 0xF0) | (data[right] & 0x0F);
        ++left;
        --right;
    }
    if ((data_len & 1) > 0)
        rev[data_len / 2] =
                (data[data_len / 2] & 0xF0) | (data[data_len / 2] & 0x0F);
    return rev;
}

uint64_t reverse_64(uint64_t word)
{
    word = ((word & 0x00000000FFFFFFFF) << 32) |
           ((word & 0xFFFFFFFF00000000) >> 32);
    word = ((word & 0x0000FFFF0000FFFF) << 16) |
           ((word & 0xFFFF0000FFFF0000) >> 16);
    word = ((word & 0x00FF00FF00FF00FF) << 8) |
           ((word & 0xFF00FF00FF00FF00) >> 8);
    return word;
}

/* KEY: Arbitrarily sized secret key generated for OTP generation
 * DATA/COUNTER: a 64-bit/8-byte (uint64_t) UNIX timestamp
 * HASH: The resulting 160-bit (20-byte) HMAC SHA-1 result
 */
void hmac_sha1(const uint8_t *key, const size_t key_len, const uint8_t *data,
               const size_t data_len, uint8_t *hash, unsigned int *hash_len)
{
    uint8_t rev[key_len];
    reverse_str(key, rev, key_len);
    reverse_64(( uint64_t )(data));
    HMAC(( const EVP_MD * )EVP_sha1(), rev, key_len, ( unsigned char * )&data,
         sizeof(uint64_t), hash, hash_len);
}

uint32_t hotp(uint8_t hash[HS_LEN])
{
    int offset   = hash[HS_LEN - 1] & 0xF;
    int bin_code = (hash[offset] & 0x7F) << 24 |
                   (hash[offset + 1] & 0xFF) << 16 |
                   (hash[offset + 2] & 0xFF) << 8 | (hash[offset + 3] & 0xFF);
    return ( uint32_t )bin_code % ( uint32_t )pow[DIGITS - 1];
}

// vim: ft=c ts=4 sts=4 sw=4 et ai cin
